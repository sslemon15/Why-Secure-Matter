(* =============================================================
   Matter OTA ProVerif Model
  -------------------------------------------------------------
   High-level mapping to Matter 1.4 OTA (§ OTA Software Updates):
   - Vendor: origin of signed firmware image and version (NSV)
   - OTA Provider: answers QueryImage, serves the image, authorizes Apply
   - OTA Requestor: queries, verifies, applies
  - Here I abstracted the best-case scenario where there is no Busy response, no re-query needed, and no token fallback

   Crypto/transport abstraction:
   - AEAD channels (i2r and r2i [directional keys]) with nonces built from flags||ctr||nodeID
   - Signature over firmware hash by Vendor; Requestor verifies it

   Monotonicity & anti-rollback:
   - ver_gt models “newer-than” (axiomatized: NEW() > CUR())
   - Guards placed before download/apply on both sides
   - Post-condition asserts OTAEnd implies previous VersionAccepted

   Idempotency & retries:
   - Requestor contains a Busy -> re-query branch
   - Provider is kept minimal (single response path), but guarded
   ============================================================= *)

free net : channel.
const nil: bitstring.

(* === Base types and results === *)
(* Symmetric keys, key material for signatures, public/secret keys, and result tag *)
type key.
type keymat.
type pkey.
type skey.
type result.
type string.

(* Firmware payload abstract type *)
type image.

(* Success result constructor *)
fun ok(): result.

(* Bitstring serialization of firmware images (used for hashing/signature) *)
fun image_to_bitstring(image): bitstring [data, typeConverter].
fun bs2str(bitstring): string [data, typeConverter].
(* === AEAD channel (abstract secure transport) === *)
(* AEAD message construction (Matter, secure unicast)
   Structure: the protected frame is A || C, where A = Message Header used as AAD,
   and C = ciphertext || AEAD tag (MIC). The AAD equals the on-wire header fields:
MessageFlags || SessionID || SecurityFlags || MessageCounter || [SourceNodeID] || [DestinationNodeID] || [Extensions].

    Secure Unicast header privacy: S=0 and DSIZ=0 ⇒ Source/Destination Node IDs are omitted from the header.
    Thus, Node IDs are not visible on the wire.
    In CASE, SourceNodeID for the nonce is obtained from the secure session context (not from the header);
    Model mapping :

        AAD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr, nil, nil) // IDs omitted as per unicast

        Nonce = nonce(SECFLAGS_UNICAST, ctr, src_ctx) // src_ctx = SourceNodeID from session context
*)

fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = ok().

(* === Hash === *)
(* Cryptographic hash function for firmware integrity verification.
   Matter specification mandates SHA-256 for firmware image integrity checks.
   Here I model it as an abstract collision-resistant hash function. *)
fun hash(bitstring) : bitstring.

(* === Nonce derivation === *)
(* Modeled as concatenation of SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* === Vendor signature interface === *)
(* Public/secret key extraction from key material; signing operation *)
fun pk(keymat): pkey.
fun sk(keymat): skey.
fun sign(bitstring, skey): bitstring.

(* Perfect signature theory: get message from a valid signature, and check verifies *)
reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Vendor’s key material: secret; public key is pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Private Vendor -> Provider provisioning channel (trusted backchannel).
   In practice, this represents secure distribution of firmware images and metadata
   through various means (e.g., HTTPS from vendor servers, DCL queries, or pre-cached
   content). Here I abstract this as a private channel where firmware updates
   are securely provisioned to OTA Providers before client requests. *)
free cv : channel [private].

(* === Message layer constants (abstract) === *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* === Application messages with strong tags === *)
(* Requestor -> Provider: QueryImage with VendorID, ProductID, Current SW version *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].  (* (VID, PID, CUR()) *)

(* Provider -> Requestor: QueryImageResponse: UpdateAvailable payload fields *)
(* NSV=New SoftwareVersion, utok=UpdateToken, dly=Delay, URI hint, VersionString *)
fun QI_AVAIL(bitstring, bitstring, bitstring, bitstring, string): bitstring [data].

(* Provider stubs for other statuses *)
fun QI_BUSY(bitstring): bitstring [data].
fun QI_NOTAVAIL(): bitstring [data].

(* Safe recognizers used to case-analyze responses without leaking structure *)
reduc forall a:bitstring,b:bitstring,c:bitstring,u:bitstring,vs:string;
  is_QI_AVAIL(QI_AVAIL(a,b,c,u,vs)) = ok().
reduc forall d:bitstring; is_QI_BUSY(QI_BUSY(d)) = ok().
reduc is_QI_NOTAVAIL(QI_NOTAVAIL()) = ok().


(* === Download message === *)
(* Provider -> Requestor: carries the firmware image, its digest, and signature *)
fun M_DL(image, bitstring, bitstring): bitstring [data].  (* (FWIMG, digest, sig) *)

(* === Apply phase === *)
(* Requestor -> Provider: ApplyUpdateRequest(UpdateToken, NewVersion) *)
fun M_APPLY_REQ(bitstring, bitstring): bitstring [data].
(* Provider -> Requestor: ApplyUpdateResponse(Action, Delay) *)
fun M_APPLY_RESP(bitstring, bitstring): bitstring [data].            (* (Action, Delay) *)
free ACT_PROCEED : bitstring.
free ACT_AWAIT   : bitstring.
free ACT_DISCONTINUE : bitstring.

(* === Demo identifiers & constructors === *)
free VID   : bitstring.
free PID   : bitstring.
fun CUR(): bitstring [data].
fun NEW(): bitstring [data].     (* 0-ary constructor for a valid new version *)
fun URI(): bitstring.            (* 0-ary constructor for a valid URI value *)

(* === Version order === *)
(* ver_gt models “newer-than”; axiomatically, NEW() > CUR() *)
fun ver_gt(bitstring, bitstring): result.
equation ver_gt(NEW(), CUR()) = ok().

(* === URI usability predicate (abstract) === *)
fun uri_ok(bitstring): result.
equation uri_ok(URI()) = ok().

(* === Events (for correspondence proofs) === *)
(* Lifecycle *)
event OTABegin(bitstring, bitstring, bitstring).
event OTAEnd(bitstring, bitstring, bitstring).

(* Query/answer & download milestones *)
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring, image).
event DownloadDone(bitstring, bitstring, bitstring, bitstring, image).

(* Transport sent/received (for anti-replay per (sid,ctr)) *)
event SendI2R(bitstring, bitstring, bitstring).
event SendR2I(bitstring, bitstring, bitstring).
event RecvI2R(bitstring, bitstring, bitstring).
event RecvR2I(bitstring, bitstring, bitstring).

(* Busy/retry bookkeeping *)
event BusyRcv(bitstring).
event RequerySameProv(bitstring).

(* Authenticity-on-image semantics *)
(* issued: Vendor issued (fw, nsv); authenticated: Requestor verified (fw, nsv) *)
event issued(image, bitstring).
event authenticated(image, bitstring).

(* Apply / token tracking *)
event TokenIssuedSID(bitstring, bitstring).
event ReadyToApply(bitstring).           (* sid *)
event ApplyReqSent(bitstring, bitstring, bitstring).(* sid, token, nsv *)
event ApplyReqRcv (bitstring, bitstring, bitstring).(* sid, token *)
event ApplyRespSent(bitstring, bitstring).
event ApplyRespRcv (bitstring, bitstring).

(* Version gating witness (Client-side decision) *)
event VersionAccepted(bitstring, bitstring). (* CUR(), NSV *)
event VersionEligible(bitstring, bitstring).     
event VersionAcceptedStrong(bitstring, bitstring).

(* Role termination (reachability beacons) *)
event endP().
event endR().

(* === Vendor role === *)
(* Publishes a fresh firmware image, computes hash and signature, announces nsv *)
let Vendor() =
  new fwimg : image;
  let fwbs = image_to_bitstring(fwimg) in
  let dg   = hash(fwbs) in
  let sigf = sign(dg, sk(KM_VENDOR)) in
  let nsv  = NEW() in           (* Vendor announces the next software version *)
  event issued(fwimg, nsv);     (* Tie issuance to (image, version) *)
  out(cv, (URI(), dg, fwimg, sigf, nsv)).

(* === Provider role (parametric in keys/session) === *)
(* Receives QueryImage, pulls Vendor tuple, enforces ver_gt, answers, sends image, handles Apply *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =

  (* Fetch Vendor provisioning tuple: (URI, digest, firmware image, signature, nsv) *)
    in(cv, (u:bitstring, dig:bitstring, fw:image, sigf:bitstring, nsv:bitstring));

  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
    let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
    let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
    event RecvI2R(sidQ, ctrQ, msg);

    

    new utok: bitstring;                   (* Fresh update token for this session *)
    event TokenIssuedSID(sid, utok);
    new dlyR: bitstring;                   (* Abstract provider delay field *)

    (* VersionString derived from nsv (modeled as stringify), as a Human readable parameter of the QI_Resp of the fw version *)
    let vstr = bs2str(nsv) in

    (* === Provider-side monotonicity guard === *)
    (* Matter: Provider SHALL only provide a numerically newer image than csv *)
    if ver_gt(nsv, csv) = ok() then
      (* Reply UpdateAvailable with (nsv, token, delay, URI, VersionString) *)
      let resp = QI_AVAIL(nsv, utok, dlyR, u, vstr) in

      (* Send response over r2i secure channel *)
      new ctr_r2i1: bitstring;
      let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
      let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
      event SendR2I(sid, ctr_r2i1, resp);
      event QueryAnsweredP(sid, provId, VID, PID, nsv);
      out(net, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

      (* Immediately follow with the (abstract) image transfer message *)
      event DownloadStart(sid, provId, u, fw);
      let dl = M_DL(fw, dig, sigf) in
      new ctr_r2i2: bitstring;
      let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
      let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
      event SendR2I(sid, ctr_r2i2, dl);
      out(net, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
      (* If not newer, Provider refuses to serve an update *)

      (* Apply phase handling: validate Apply request and authorize proceed *)
      (* Note that the token is not explicitly verified, since as stated in Matter Core Spec 1.4: "The OTA Provider SHALL
          NOT consider an invalid UpdateToken as a reason to continuously deny or delay an OTA
          Requestor’s request to apply a Software Image." *)
      in(net, (aadA:bitstring, ctA:bitstring));
      let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
      let nA = nonce(sfA, ctrA, src_ctx) in
      if aead_dec_validate(k_i2r, ctA, nA, aadA) = ok() then
        let areq = aead_dec(k_i2r, ctA, nA, aadA) in
        let M_APPLY_REQ(tk:bitstring, nv:bitstring) = areq in
        event RecvI2R(sidA, ctrA, areq);
        event ApplyReqRcv(sidA, tk, nv);

        (* Coherence: NewVersion in Apply must equal nsv previously announced *)
        if nv = nsv then
          new delay: bitstring;
          let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
          new ctr_r2i3: bitstring;
          let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
          let nAR   = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
          event SendR2I(sid, ctr_r2i3, aresp);
          event ApplyRespSent(sid, ACT_PROCEED);
          out(net, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
          event endP(); 0
        else 0
      else 0
    else 0
  else 0.

(* === Requestor role (with Busy -> requery loop) === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* Begin OTA lifecycle *)
  event OTABegin(reqId, provId, CUR());

  (* Send QueryImage with (VID, PID, CUR()) *)
  let q = M_QI(VID, PID, CUR()) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, CUR());
  out(net, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* Receive Provider’s response *)
  in(net, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  if aead_dec_validate(k_r2i, ctR, nR, aadR) = ok() then
    let r = aead_dec(k_r2i, ctR, nR, aadR) in

        if is_QI_AVAIL(r) = ok() then
      (* Parse UpdateAvailable *)
      let QI_AVAIL(nsv:bitstring, utok:bitstring, dly:bitstring, uri_hint:bitstring, vstr:string) = r in
      event RecvR2I(sidR, ctrR, r);

      (* === Requestor-side monotonicity guard and URI check === *)
      (* Matter: Requestor SHALL only upgrade to numerically newer versions *)
      if ver_gt(nsv, CUR()) = ok() then
         event VersionEligible(CUR(), nsv);
      if uri_ok(uri_hint) = ok() then
        (* Receive image transfer *)
        in(net, (aadD:bitstring, ctD:bitstring));
        let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
        let nD = nonce(sfD, ctrD, src_ctx) in
        if aead_dec_validate(k_r2i, ctD, nD, aadD) = ok() then
          let dl = aead_dec(k_r2i, ctD, nD, aadD) in
          let M_DL(fw:image, digest:bitstring, sigf:bitstring) = dl in
          event RecvR2I(sidD, ctrD, dl);
            
              (* Verify Vendor signature and bind it to the actual image hash *)
              if checksign(sigf, pk(KM_VENDOR)) = ok() then
                let m = getmess(sigf) in
                if m = hash(image_to_bitstring(fw)) then
                  if digest = hash(image_to_bitstring(fw)) then
                    event authenticated(fw, nsv);  (* Image authenticity proven *)
                    event VersionAcceptedStrong(CUR(), nsv);
                    event DownloadDone(sidD, reqId, provId, uri_hint, fw);
                    event ReadyToApply(sidD);

                    (* Send ApplyUpdateRequest with (utok, nsv) *)
                    let areq = M_APPLY_REQ(utok, nsv) in
                    new ctr_i2r2: bitstring;
                    let aadA = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2, nil, nil) in
                    let nA   = nonce(SECFLAGS_UNICAST, ctr_i2r2, src_ctx) in
                    event SendI2R(sid, ctr_i2r2, areq);
                    event ApplyReqSent(sid, utok, nsv);
                    out(net, (aadA, aead_enc(k_i2r, areq, nA, aadA)));

                    (* Receive Apply response *)
                    in(net, (aadAR:bitstring, ctAR:bitstring));
                    let (mfAR:bitstring, sidAR:bitstring, sfAR:bitstring, ctrAR:bitstring, srcAR:bitstring, dstAR:bitstring) = aadAR in
                    let nAR = nonce(sfAR, ctrAR, src_ctx) in
                    if aead_dec_validate(k_r2i, ctAR, nAR, aadAR) = ok() then
                      let rAR = aead_dec(k_r2i, ctAR, nAR, aadAR) in
                      let M_APPLY_RESP(act:bitstring, dlyA:bitstring) = rAR in
                      event RecvR2I(sidAR, ctrAR, rAR);
                      event ApplyRespRcv(sidAR, act);
                      if act = ACT_PROCEED then
                        event OTAEnd(reqId, provId, nsv);  (* Successful end of OTA *)
                        event endR(); 0
                      else 0
                    else 0
                  else 0
                else 0
              else 0
            else 0
          else 0
        else 0
      else 0


    (* === CASE 2: Provider says Busy -> Requestor retries once === *)
else if is_QI_BUSY(r) = ok() then
  let QI_BUSY(dly2:bitstring) = r in
  event RecvR2I(sidR, ctrR, r);
  event BusyRcv(provId);

  (* Re-issue QueryImage with the same (VID, PID, CUR()) *)
  let q2 = M_QI(VID, PID, CUR()) in
  new ctr_i2r1b: bitstring;
  let aadQb = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1b, nil, nil) in
  let nQb   = nonce(SECFLAGS_UNICAST, ctr_i2r1b, src_ctx) in
  event RequerySameProv(provId);
  event SendI2R(sid, ctr_i2r1b, q2);
  out(net, (aadQb, aead_enc(k_i2r, q2, nQb, aadQb)));

  (* Receive the second response, ideally QI_AVAIL *)
  in(net, (aadRb:bitstring, ctRb:bitstring));
  let (mfRb:bitstring, sidRb:bitstring, sfRb:bitstring, ctrRb:bitstring, srcRb:bitstring, dstRb:bitstring) = aadRb in
  let nRb = nonce(sfRb, ctrRb, src_ctx) in
  if aead_dec_validate(k_r2i, ctRb, nRb, aadRb) = ok() then
    let rb = aead_dec(k_r2i, ctRb, nRb, aadRb) in
    if is_QI_AVAIL(rb) = ok() then
      let QI_AVAIL(nsvb:bitstring, utokb:bitstring, dlyb:bitstring, uri_hintb:bitstring, vstrb:string) = rb in
      event RecvR2I(sidRb, ctrRb, rb);

      (* Same monotonicity & URI guards as above *)
      if ver_gt(nsvb, CUR()) = ok() then
        event VersionAccepted(CUR(), nsvb);
      if uri_ok(uri_hintb) = ok() then
        (* Receive image transfer for the retried flow *)
        in(net, (aadDb:bitstring, ctDb:bitstring));
        let (mfDb:bitstring, sidDb:bitstring, sfDb:bitstring, ctrDb:bitstring, srcDb:bitstring, dstDb:bitstring) = aadDb in
        let nDb = nonce(sfDb, ctrDb, src_ctx) in
        if aead_dec_validate(k_r2i, ctDb, nDb, aadDb) = ok() then
          let dlb = aead_dec(k_r2i, ctDb, nDb, aadDb) in
          let M_DL(fwb:image, digestb:bitstring, sigfb:bitstring) = dlb in
          event RecvR2I(sidDb, ctrDb, dlb);

              (* Verify signature/hash again for the retried path *)
              if checksign(sigfb, pk(KM_VENDOR)) = ok() then
                let mb = getmess(sigfb) in
                if mb = hash(image_to_bitstring(fwb)) then
                  if digestb = hash(image_to_bitstring(fwb)) then
                    event authenticated(fwb, nsvb);
                    event DownloadDone(sidDb, reqId, provId, uri_hintb, fwb);
                    event ReadyToApply(sidDb);

                    (* Apply immediately using utokb, nsvb on retry *)
                    let areqb = M_APPLY_REQ(utokb, nsvb) in
                    new ctr_i2r2b: bitstring;
                    let aadAb = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2b, nil, nil) in
                    let nAb   = nonce(SECFLAGS_UNICAST, ctr_i2r2b, src_ctx) in
                    event SendI2R(sid, ctr_i2r2b, areqb);
                    event ApplyReqSent(sid, utokb , nsvb);
                    out(net, (aadAb, aead_enc(k_i2r, areqb, nAb, aadAb)));

                    (* Receive Apply response for retry case *)
                    in(net, (aadARb:bitstring, ctARb:bitstring));
                    let (mfARb:bitstring, sidARb:bitstring, sfARb:bitstring, ctrARb:bitstring, srcARb:bitstring, dstARb:bitstring) = aadARb in
                    let nARb = nonce(sfARb, ctrARb, src_ctx) in
                    if aead_dec_validate(k_r2i, ctARb, nARb, aadARb) = ok() then
                      let rARb = aead_dec(k_r2i, ctARb, nARb, aadARb) in
                      let M_APPLY_RESP(actb:bitstring, dlyAb:bitstring) = rARb in
                      event RecvR2I(sidARb, ctrARb, rARb);
                      event ApplyRespRcv(sidARb, actb);
                      if actb = ACT_PROCEED then
                        event OTAEnd(reqId, provId, nsvb);
                        event endR(); 0
                      else 0
                    else 0
                  else 0
                else 0
              else 0
            else 0
          else 0
        else 0
      else 0
    else 0
  else 0.

(* === Security properties (queries) === *)

(* Key secrecy: the Vendor private signing key must remain unknown *)
query attacker(sk(KM_VENDOR)).


(* (Just for correspondence: DownloadDone implies a preceding DownloadStart from the same provider/URI/image *)
query sid:bitstring,r:bitstring, p:bitstring, u:bitstring, f:image;
  event(DownloadDone(sid, r, p, u, f)) ==> event(DownloadStart(sid, p, u, f)).

(* Authenticity of installed image: anything authenticated must have been issued by Vendor *)
query fw: image, nv: bitstring;
  event(authenticated(fw, nv)) ==> event(issued(fw, nv)).

(* Ordering: Provider must have answered a QueryImage before any download starts *)
query sid:bitstring, p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:image;
  event(DownloadStart(sid, p, u, f)) ==> event(QueryAnsweredP(sid, p, vid, pid, nsv)).

(* Anti-replay (injective) on both directions, keyed by (sid, ctr) *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* Apply-phase authentication *)
query sid:bitstring, act:bitstring;
  event(ApplyRespRcv(sid,  act)) ==> inj-event(ApplyRespSent(sid,  act)).

(* Readiness discipline: ApplyReq only after ReadyToApply event *)
query sid:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyReqSent(sid, tok, nsv)) ==> event(ReadyToApply(sid)).

(* Full apply handshake: response received only after a matching sent and received request *)
query sid:bitstring, act:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyRespRcv(sid, act))
   ==> ( inj-event(ApplyRespSent(sid, act))
        ==> inj-event(ApplyReqRcv(sid, tok, nsv)) ).

(* Token freshness: any ApplyReq must reference a token issued for the same session *)
query sid:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyReqSent(sid, tok, nsv)) ==> event(TokenIssuedSID(sid, tok)).

(* Reachability beacons: both roles can terminate in at least one trace *)
query event(endP()).
query event(endR()).

(* === Process: concurrently spawn multiple independent sessions === *)
process
  !(
     new k_i2r : key;            (* AEAD key for I->R direction *)
     new k_r2i : key;            (* AEAD key for R->I direction *)
     new ReqId : bitstring;      (* Requestor identity / correlation id *)
     new ProvId: bitstring;      (* Provider identity / correlation id *)
     new SESSID: bitstring;      (* Session identifier used in AAD/events *)
     new SRC_CTX: bitstring;     (* Represents the NodeIDs from the session context *)
     ( Vendor()
     | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) 
     | (  (* === SCENARIO A: leak operational AEAD keys only === *)
     out(net, k_i2r);
     out(net, k_r2i)
     ))
   )

(*This analysis examines a compromised key scenario in Matter CASE resumption attacks.
  While CASE resumption provides weaker security guarantees than full CASE establishment allowing 
  attackers to derive operational keys from leaked ephemeral keys—the protocol maintains its security
  properties. Even with operational AEAD keys, attackers cannot decrypt messages or violate integrity
  because they lack the Source Node IDs required for proper nonce construction, which depends on 
  the unavailable IPK. Consequently, all fundamental security properties are preserved despite the
  key compromise. *)

(*ref. of derivation: 
    I2RKey || R2IKey || AttestationChallenge = Crypto_KDF(
        inputKey = SharedSecret,
        salt     = Sigma1.initiatorRandom || ResumptionID,
        info     = "SessionResumptionKeys",
        len      = 3 * keylen
    )
*)