(* =============================================================
   Matter OTA ProVerif Model
  -------------------------------------------------------------
   High-level mapping to Matter 1.4 OTA (§ OTA Software Updates):
   - Vendor: origin of signed firmware image and version (NSV)
   - OTA Provider: answers QueryImage, serves the image, authorizes Apply
   - OTA Requestor: queries, verifies, applies
  - Here I abstracted the best-case scenario where there is no Busy response, no re-query needed, and no token fallback

   Crypto/transport abstraction:
   - AEAD channels (i2r and r2i [directional keys]) with nonces built from flags||ctr||nodeID
   - Signature over firmware hash by Vendor; Requestor verifies it

   Monotonicity & anti-rollback:
   - ver_gt models “newer-than” (axiomatized: NEW() > CUR())
   - Guards placed before download/apply on both sides
   - Post-condition asserts OTAEnd implies previous VersionAccepted

   Idempotency & retries:
   - Requestor contains a Busy -> re-query branch
   - Provider is kept minimal (single response path), but guarded
   ============================================================= *)

free net : channel.
const nil: bitstring.

(* === Base types and results === *)
(* Symmetric keys, key material for signatures, public/secret keys, and result tag *)
type key.
type keymat.
type pkey.
type skey.
type result.
type string.

(* Firmware payload abstract type *)
type image.

(* Success result constructor *)
fun ok(): result.

(* Bitstring serialization of firmware images (used for hashing/signature) *)
fun image_to_bitstring(image): bitstring [data, typeConverter].
fun bs2str(bitstring): string [data, typeConverter].
(* === AEAD channel (abstract secure transport) === *)
(* AEAD message construction (Matter, secure unicast)
   Structure: the protected frame is A || C, where A = Message Header used as AAD,
   and C = ciphertext || AEAD tag (MIC). The AAD equals the on-wire header fields:
MessageFlags || SessionID || SecurityFlags || MessageCounter || [SourceNodeID] || [DestinationNodeID] || [Extensions].

    Secure Unicast header privacy: S=0 and DSIZ=0 ⇒ Source/Destination Node IDs are omitted from the header.
    Thus, Node IDs are not visible on the wire.
    In CASE, SourceNodeID for the nonce is obtained from the secure session context (not from the header);
    Model mapping :

        AAD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr, nil, nil) // IDs omitted as per unicast

        Nonce = nonce(SECFLAGS_UNICAST, ctr, src_ctx) // src_ctx = SourceNodeID from session context
*)

fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = ok().

(* === Hash === *)
(* Cryptographic hash function for firmware integrity verification.
   Matter specification mandates SHA-256 for firmware image integrity checks.
   Here I model it as an abstract collision-resistant hash function. *)
fun hash(bitstring) : bitstring.

(* === Nonce derivation === *)
(* Modeled as concatenation of SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* === Vendor signature interface === *)
(* Public/secret key extraction from key material; signing operation *)
fun pk(keymat): pkey.
fun sk(keymat): skey.
fun sign(bitstring, skey): bitstring.

(* Perfect signature theory: get message from a valid signature, and check verifies *)
reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Vendor’s key material: secret; public key is pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Private Vendor -> Provider provisioning channel (trusted backchannel).
   In practice, this represents secure distribution of firmware images and metadata
   through various means (e.g., HTTPS from vendor servers, DCL queries, or pre-cached
   content). Here I abstract this as a private channel where firmware updates
   are securely provisioned to OTA Providers before client requests. *)
free cv : channel [private].

(* === Message layer constants (abstract) === *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* === Application messages with strong tags === *)
(* Requestor -> Provider: QueryImage with VendorID, ProductID, Current SW version *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].  (* (VID, PID, CUR()) *)

(* Provider -> Requestor: QueryImageResponse: UpdateAvailable payload fields *)
(* NSV=New SoftwareVersion, utok=UpdateToken, dly=Delay, URI hint, VersionString *)
fun QI_AVAIL(bitstring, bitstring, bitstring, bitstring, string): bitstring [data].

(* Provider stubs for other statuses *)
fun QI_BUSY(bitstring): bitstring [data].
fun QI_NOTAVAIL(): bitstring [data].

(* Safe recognizers used to case-analyze responses without leaking structure *)
reduc forall a:bitstring,b:bitstring,c:bitstring,u:bitstring,vs:string;
  is_QI_AVAIL(QI_AVAIL(a,b,c,u,vs)) = ok().
reduc forall d:bitstring; is_QI_BUSY(QI_BUSY(d)) = ok().
reduc is_QI_NOTAVAIL(QI_NOTAVAIL()) = ok().


(* === Download message === *)
(* Provider -> Requestor: carries the firmware image, its digest, and signature *)
fun M_DL(image, bitstring, bitstring): bitstring [data].  (* (FWIMG, digest, sig) *)

(* === Apply phase === *)
(* Requestor -> Provider: ApplyUpdateRequest(UpdateToken, NewVersion) *)
fun M_APPLY_REQ(bitstring, bitstring): bitstring [data].
(* Provider -> Requestor: ApplyUpdateResponse(Action, Delay) *)
fun M_APPLY_RESP(bitstring, bitstring): bitstring [data].            (* (Action, Delay) *)
free ACT_PROCEED : bitstring.
free ACT_AWAIT   : bitstring.
free ACT_DISCONTINUE : bitstring.

(* === Demo identifiers & constructors === *)
free VID   : bitstring.
free PID   : bitstring.
fun CUR(): bitstring [data].
fun NEW(): bitstring [data].     (* 0-ary constructor for a valid new version *)
fun URI(): bitstring.            (* 0-ary constructor for a valid URI value *)

(* === Version order === *)
(* ver_gt models “newer-than”; axiomatically, NEW() > CUR() *)
fun ver_gt(bitstring, bitstring): result.
equation ver_gt(NEW(), CUR()) = ok().

(* === URI usability predicate (abstract) === *)
fun uri_ok(bitstring): result.
equation uri_ok(URI()) = ok().

(* === Events (for correspondence proofs) === *)
(* Lifecycle *)
event OTABegin(bitstring, bitstring, bitstring).
event OTAEnd(bitstring, bitstring, bitstring).

(* Query/answer & download milestones *)
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring, image).
event DownloadDone(bitstring, bitstring, bitstring, bitstring, image).

(* Transport sent/received (for anti-replay per (sid,ctr)) *)
event SendI2R(bitstring, bitstring, bitstring).
event SendR2I(bitstring, bitstring, bitstring).
event RecvI2R(bitstring, bitstring, bitstring).
event RecvR2I(bitstring, bitstring, bitstring).

(* Busy/retry bookkeeping *)
event BusyRcv(bitstring).
event RequerySameProv(bitstring).

(* Authenticity-on-image semantics *)
(* issued: Vendor issued (fw, nsv); authenticated: Requestor verified (fw, nsv) *)
event issued(image, bitstring).
event authenticated(image, bitstring).

(* Apply / token tracking *)
event TokenIssuedSID(bitstring, bitstring).
event ReadyToApply(bitstring).           (* sid *)
event ApplyReqSent(bitstring, bitstring, bitstring).(* sid, token, nsv *)
event ApplyReqRcv (bitstring, bitstring, bitstring).(* sid, token *)
event ApplyRespSent(bitstring, bitstring).
event ApplyRespRcv (bitstring, bitstring).

(* Version gating witness (Client-side decision) *)
event VersionAccepted(bitstring, bitstring). (* CUR(), NSV *)
event VersionEligible(bitstring, bitstring).     
event VersionAcceptedStrong(bitstring, bitstring).

event bdx_semantics_complete(bitstring, bitstring, image).     (* Lemma used by the baseline OTA: bdx_complete ≡ bdx_semantics_complete *)

(* Role termination (reachability beacons) *)
event endP().
event endR().

(* === Vendor role === *)
let Vendor() =
  new fwimg : image;
  let fwbs = image_to_bitstring(fwimg) in
  let dg   = hash(fwbs) in
  let sigf = sign(dg, sk(KM_VENDOR)) in
  let nsv  = NEW() in
  event issued(fwimg, nsv);
  out(cv, (URI(), dg, fwimg, sigf, nsv)).

(* === Provider role (parametric in keys/session) === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =

  (* Pull Vendor provisioning tuple *)
  in(cv, (u:bitstring, dig:bitstring, fw:image, sigf:bitstring, nsv:bitstring));

  (* --- Receive QueryImage --- *)
  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  if sidQ = sid then
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
  let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
  let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
  event RecvI2R(sid, ctrQ, msg);

  new utok: bitstring;
  event TokenIssuedSID(sid, utok);
  new dlyR: bitstring;
  let vstr = bs2str(nsv) in

  (* Provider-side monotonicity guard *)
  if ver_gt(nsv, csv) = ok() then
  let resp = QI_AVAIL(nsv, utok, dlyR, u, vstr) in

  (* Send UpdateAvailable *)
  new ctr_r2i1: bitstring;
  let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
  let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
  event SendR2I(sid, ctr_r2i1, resp);
  event QueryAnsweredP(sid, provId, VID, PID, nsv);
  out(net, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

  (* Send Download *)
  event DownloadStart(sid, provId, u, fw);
  let dl = M_DL(fw, dig, sigf) in
  new ctr_r2i2: bitstring;
  let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
  let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
  event SendR2I(sid, ctr_r2i2, dl);
  event bdx_semantics_complete(sid, dig, fw); (* Lemma used by the baseline OTA: bdx_complete ≡ bdx_semantics_complete *)
  out(net, (aadD, aead_enc(k_r2i, dl, nD, aadD)));

  (* --- Receive ApplyUpdateRequest --- *)
  in(net, (aadA:bitstring, ctA:bitstring));
  let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
  if sidA = sid then
  let nA = nonce(sfA, ctrA, src_ctx) in
  if aead_dec_validate(k_i2r, ctA, nA, aadA) = ok() then
  let areq = aead_dec(k_i2r, ctA, nA, aadA) in
  let M_APPLY_REQ(tk:bitstring, nv:bitstring) = areq in
  event RecvI2R(sid, ctrA, areq);
  event ApplyReqRcv(sid, tk, nv);

  if nv = nsv then
  new delay: bitstring;
  let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
  new ctr_r2i3: bitstring;
  let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
  let nAR   = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
  event SendR2I(sid, ctr_r2i3, aresp);
  event ApplyRespSent(sid, ACT_PROCEED);
  out(net, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
  event endP(); 0.

(* === Requestor role (with Busy -> single requery) === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =

  event OTABegin(reqId, provId, CUR());

  (* Send QueryImage *)
  let q = M_QI(VID, PID, CUR()) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, CUR());
  out(net, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* --- Receive Provider response --- *)
  in(net, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  if sidR = sid then
  let nR = nonce(sfR, ctrR, src_ctx) in
  if aead_dec_validate(k_r2i, ctR, nR, aadR) = ok() then
  let r = aead_dec(k_r2i, ctR, nR, aadR) in

  if is_QI_AVAIL(r) = ok() then
  let QI_AVAIL(nsv:bitstring, utok:bitstring, dly:bitstring, uri_hint:bitstring, vstr:string) = r in
  event RecvR2I(sid, ctrR, r);

  if ver_gt(nsv, CUR()) = ok() then
  event VersionEligible(CUR(), nsv);
  if uri_ok(uri_hint) = ok() then

  (* --- Receive Download --- *)
  in(net, (aadD:bitstring, ctD:bitstring));
  let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
  if sidD = sid then
  let nD = nonce(sfD, ctrD, src_ctx) in
  if aead_dec_validate(k_r2i, ctD, nD, aadD) = ok() then
  let dl = aead_dec(k_r2i, ctD, nD, aadD) in
  let M_DL(fw:image, digest:bitstring, sigf:bitstring) = dl in
  event RecvR2I(sid, ctrD, dl);

  if checksign(sigf, pk(KM_VENDOR)) = ok() then
  let m = getmess(sigf) in
  if m = hash(image_to_bitstring(fw)) then
  if digest = hash(image_to_bitstring(fw)) then
  event authenticated(fw, nsv);
  event VersionAcceptedStrong(CUR(), nsv);
  event DownloadDone(sid, reqId, provId, uri_hint, fw);
  event ReadyToApply(sid);

  (* Send ApplyUpdateRequest *)
  let areq = M_APPLY_REQ(utok, nsv) in
  new ctr_i2r2: bitstring;
  let aadA = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2, nil, nil) in
  let nA   = nonce(SECFLAGS_UNICAST, ctr_i2r2, src_ctx) in
  event SendI2R(sid, ctr_i2r2, areq);
  event ApplyReqSent(sid, utok, nsv);
  out(net, (aadA, aead_enc(k_i2r, areq, nA, aadA)));

  (* --- Receive Apply response --- *)
  in(net, (aadAR:bitstring, ctAR:bitstring));
  let (mfAR:bitstring, sidAR:bitstring, sfAR:bitstring, ctrAR:bitstring, srcAR:bitstring, dstAR:bitstring) = aadAR in
  if sidAR = sid then
  let nAR = nonce(sfAR, ctrAR, src_ctx) in
  if aead_dec_validate(k_r2i, ctAR, nAR, aadAR) = ok() then
  let rAR = aead_dec(k_r2i, ctAR, nAR, aadAR) in
  let M_APPLY_RESP(act:bitstring, dlyA:bitstring) = rAR in
  event RecvR2I(sid, ctrAR, rAR);
  event ApplyRespRcv(sid, act);
  if act = ACT_PROCEED then
  event OTAEnd(reqId, provId, nsv);
  event endR(); 0.

(* === Security properties (queries) === *)

(* Key secrecy: the Vendor private signing key must remain unknown *)
query attacker(sk(KM_VENDOR)).


(* (Just for correspondence: DownloadDone implies a preceding DownloadStart from the same provider/URI/image *)
query sid:bitstring,r:bitstring, p:bitstring, u:bitstring, f:image;
  event(DownloadDone(sid, r, p, u, f)) ==> event(DownloadStart(sid, p, u, f)).

(* Authenticity of installed image: anything authenticated must have been issued by Vendor *)
query fw: image, nv: bitstring;
  event(authenticated(fw, nv)) ==> event(issued(fw, nv)).

(* Ordering: Provider must have answered a QueryImage before any download starts *)
query sid:bitstring, p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:image;
  event(DownloadStart(sid, p, u, f)) ==> event(QueryAnsweredP(sid, p, vid, pid, nsv)).

(* Anti-replay (injective) on both directions, keyed by (sid, ctr) *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* Apply-phase authentication *)
query sid:bitstring, act:bitstring;
  event(ApplyRespRcv(sid,  act)) ==> inj-event(ApplyRespSent(sid,  act)).

(* Readiness discipline: ApplyReq only after ReadyToApply event *)
query sid:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyReqSent(sid, tok, nsv)) ==> event(ReadyToApply(sid)).

(* Full apply handshake: response received only after a matching sent and received request *)
query sid:bitstring, act:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyRespRcv(sid, act))
   ==> ( inj-event(ApplyRespSent(sid, act))
        ==> inj-event(ApplyReqRcv(sid, tok, nsv)) ).

(* Token freshness: any ApplyReq must reference a token issued for the same session *)
query sid:bitstring, tok:bitstring, nsv:bitstring;
  event(ApplyReqSent(sid, tok, nsv)) ==> event(TokenIssuedSID(sid, tok)).

(* Reachability beacons: both roles can terminate in at least one trace *)
query event(endP()).
query event(endR()).

(* === Process: concurrently spawn multiple independent sessions === *)
process
  !(
     new k_i2r : key;            (* AEAD key for I->R direction *)
     new k_r2i : key;            (* AEAD key for R->I direction *)
     new ReqId : bitstring;      (* Requestor identity / correlation id *)
     new ProvId: bitstring;      (* Provider identity / correlation id *)
     new SESSID: bitstring;      (* Session identifier used in AAD/events *)
     new SRC_CTX: bitstring;     (* Represents the NodeIDs from the session context *)
     ( Vendor()
     | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) 
     | (  (* === SCENARIO A: leak operational AEAD keys only === *)
     out(net, k_i2r);
     out(net, k_r2i)
     ))
   )

(*This analysis examines a compromised key scenario in Matter CASE resumption attacks.
  While CASE resumption provides weaker security guarantees than full CASE establishment allowing 
  attackers to derive operational keys from leaked ephemeral keys—the protocol maintains its security
  properties. Even with operational AEAD keys, attackers cannot decrypt messages or violate integrity
  because they lack the Source Node IDs required for proper nonce construction, which depends on 
  the unavailable IPK. Consequently, all fundamental security properties are preserved despite the
  key compromise. *)

(*ref. of derivation: 
    I2RKey || R2IKey || AttestationChallenge = Crypto_KDF(
        inputKey = SharedSecret,
        salt     = Sigma1.initiatorRandom || ResumptionID,
        info     = "SessionResumptionKeys",
        len      = 3 * keylen
    )
*)