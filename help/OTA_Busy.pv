free net : channel.
const nil : bitstring.

(* === Tipi e primitive base === *)
type key.
type keymat.
type pkey.
type skey.
type result.

fun ok() : result.

(* Nuovo tipo per il firmware *)
type image.
fun image_to_bitstring(image) : bitstring [data, typeConverter].

(* Supporto per descrizioni testuali negli eventi *)
type string.
fun bs2str(bitstring) : string [data, typeConverter].

(* AEAD *)
fun aead_enc(key, bitstring, bitstring, bitstring) : bitstring.
fun aead_dec(key, bitstring, bitstring, bitstring) : bitstring.
fun aead_dec_validate(key, bitstring, bitstring, bitstring) : result.

reduc
  forall k:key, m:bitstring, n:bitstring, ad:bitstring;
    aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc
  forall k:key, m:bitstring, n:bitstring, ad:bitstring;
    aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = ok().

(* Hash *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring) : bitstring.

(* Firma VENDOR *)
fun pk(keymat) : pkey.
fun sk(keymat) : skey.
fun sign(bitstring, skey) : bitstring.
fun getmess(bitstring) : bitstring.
fun checksign(bitstring, pkey) : result.

reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Chiave vendor: segreta; la pubblica è pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Canale privato Vendor->Provider *)
free cv : channel [private].

(* Costanti Message Layer *)
free MSGFLAGS : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* Messaggi applicativi con tag “forte” *)
fun M_QI(bitstring, bitstring, bitstring) : bitstring [data].  (* (VID, PID, CUR()) *)

(* QueryImageResponse: Status = UpdateAvailable *)
(* campi: NSV (SoftwareVersion), utok (UpdateToken), dly, ImageURI, VersionString *)
fun QI_AVAIL(bitstring, bitstring, bitstring, bitstring, string) : bitstring [data].
fun QI_BUSY(bitstring) : bitstring [data].
fun QI_NOTAVAIL() : bitstring [data].

(* Predicati di forma per branch sicuri *)
fun is_QI_AVAIL(bitstring) : result.
fun is_QI_BUSY(bitstring) : result.
fun is_QI_NOTAVAIL(bitstring) : result.

reduc forall a:bitstring, b:bitstring, c:bitstring, u:bitstring, vs:string;
  is_QI_AVAIL(QI_AVAIL(a, b, c, u, vs)) = ok().
reduc forall d:bitstring; is_QI_BUSY(QI_BUSY(d)) = ok().
reduc is_QI_NOTAVAIL(QI_NOTAVAIL()) = ok().

(* Download: ora il 2° argomento è image *)
fun M_DL(image, bitstring, bitstring) : bitstring [data].  (* (URI, FWIMG, digest, sig) *)

(* Apply step *)
(* ApplyUpdateRequest(UpdateToken, NewVersion) *)
fun M_APPLY_REQ(bitstring, bitstring) : bitstring [data].
fun M_APPLY_RESP(bitstring, bitstring) : bitstring [data].  (* (Action, Delay) *)

free ACT_PROCEED : bitstring.
free ACT_AWAIT : bitstring.
free ACT_DISCONTINUE : bitstring.

(* --- Dati demo --- *)
free VID : bitstring.
free PID : bitstring.
fun CUR() : bitstring [data].
fun NEW() : bitstring [data].
(* lasciato per compatibilità, non usato per ver_gt *)
fun URI() : bitstring.  (* costruttore a 0 argomenti *)

(* === Versioni (monotonicità semplificata) === *)
fun ver_gt(bitstring, bitstring) : result.
equation ver_gt(NEW(), CUR()) = ok().

(* URI utilizzabile *)
fun uri_ok(bitstring) : result.
equation uri_ok(URI()) = ok().

(* Eventi *)
event OTABegin(bitstring, bitstring, bitstring).
event OTAEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, image).
event SendI2R(bitstring, bitstring, bitstring).
event SendR2I(bitstring, bitstring, bitstring).
event RecvI2R(bitstring, bitstring, bitstring).
event RecvR2I(bitstring, bitstring, bitstring).
(* Busy/re-query *)
event BusyRcv(bitstring).
event RequerySameProv(bitstring).
(* Verifica stile “issued/authenticated” sul contenuto firmato *)
event issued(bitstring, string).          (* sw = digest/firmware-id, swd = descrizione es. URI *)
event authenticated(bitstring, string).
(* Apply / token tracking *)
event TokenIssuedSID(bitstring, bitstring).
event ReadyToApply(bitstring).            (* sid *)
event ApplyReqSent(bitstring, bitstring). (* sid, token *)
event ApplyReqRcv(bitstring, bitstring).  (* sid, token *)
event ApplyRespSent(bitstring, bitstring).
event ApplyRespRcv(bitstring, bitstring).
event VersionAccepted(bitstring, bitstring). (* CUR(), NSV *)
event endP().
event endR().

(* === VENDOR: invia tutto su cv come tupla; emette 'issued' sul pair (digest, URI) === *)
let Vendor() =
  new fwimg : image;
  let fwbs = image_to_bitstring(fwimg) in
  let dg = hash(fwbs) in
  let sigf = sign(dg, sk(KM_VENDOR)) in
  let nsv = NEW() in
  (* il Vendor annuncia la versione successiva *)
  event issued(dg, bs2str(URI()));
  out(cv, (URI(), dg, fwimg, sigf, nsv)).

(* === Provider parametrico === *)
let Provider(provId:bitstring, k_i2r:key, k_r2i:key, sid:bitstring, src_ctx:bitstring) =
  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
    let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
    let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
    event RecvI2R(sidQ, ctrQ, msg);
    (* ricevi la tupla dal Vendor: include anche la nuova versione numerica nsv *)
    in(cv, (u:bitstring, dig:bitstring, fw:image, sigf:bitstring, nsv:bitstring));
    new utok:bitstring;
    event TokenIssuedSID(sid, utok);
    new dlyR:bitstring;
    (* VersionString: qui la otteniamo come conversione (modellata) del numero di versione *)
    let vstr = bs2str(nsv) in
    (* STATUS = UpdateAvailable: includiamo NSV, token, delay, ImageURI, VersionString *)
    let resp = QI_AVAIL(nsv, utok, dlyR, u, vstr) in
    new ctr_r2i1:bitstring;
    let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
    let nR = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
    event SendR2I(sid, ctr_r2i1, resp);
    event QueryAnsweredP(provId, VID, PID, nsv);
    out(net, (aadR, aead_enc(k_r2i, resp, nR, aadR)));
    (* download: usa i valori ricevuti *)
    event DownloadStart(provId, u, image_to_bitstring(fw));
    let dl = M_DL(fw, dig, sigf) in
    new ctr_r2i2:bitstring;
    let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
    let nD = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
    event SendR2I(sid, ctr_r2i2, dl);
    out(net, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
    in(net, (aadA:bitstring, ctA:bitstring));
    let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
    let nA = nonce(sfA, ctrA, src_ctx) in
    if aead_dec_validate(k_i2r, ctA, nA, aadA) = ok() then
      let areq = aead_dec(k_i2r, ctA, nA, aadA) in
      (* ApplyUpdateRequest(UpdateToken, NewVersion) *)
      let M_APPLY_REQ(tk:bitstring, nv:bitstring) = areq in
      event RecvI2R(sidA, ctrA, areq);
      event ApplyReqRcv(sidA, tk);
      (* Coerenza: NewVersion deve essere la NSV annunciata *)
      if nv = nsv then
        new delay:bitstring;
        let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
        new ctr_r2i3:bitstring;
        let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
        let nAR = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
        event SendR2I(sid, ctr_r2i3, aresp);
        event ApplyRespSent(sid, ACT_PROCEED);
        out(net, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
        event endP(); 0
      else 0
    else 0
  else 0.

(* === Requestor con gestione stati QI + “loop” === *)
let Requestor(reqId:bitstring, provId:bitstring, k_i2r:key, k_r2i:key, sid:bitstring, src_ctx:bitstring) =
  event OTABegin(reqId, provId, CUR());
  let q = M_QI(VID, PID, CUR()) in
  new ctr_i2r1:bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, CUR());
  out(net, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));
  in(net, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  if aead_dec_validate(k_r2i, ctR, nR, aadR) = ok() then
    let r = aead_dec(k_r2i, ctR, nR, aadR) in
    if is_QI_AVAIL(r) = ok() then
      (* NSV, UpdateToken, Delay, ImageURI, VersionString *)
      let QI_AVAIL(nsv:bitstring, utok:bitstring, dly:bitstring, uri_hint:bitstring, vstr:string) = r in
      event RecvR2I(sidR, ctrR, r);
      (* Verifica versione SUBITO dopo QI_AVAIL *)
      if ver_gt(nsv, CUR()) = ok() then
        event VersionAccepted(CUR(), nsv);
        if uri_ok(uri_hint) = ok() then
          in(net, (aadD:bitstring, ctD:bitstring));
          let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
          let nD = nonce(sfD, ctrD, src_ctx) in
          if aead_dec_validate(k_r2i, ctD, nD, aadD) = ok() then
            let dl = aead_dec(k_r2i, ctD, nD, aadD) in
            let M_DL(fw:image, digest:bitstring, sigf:bitstring) = dl in
            event RecvR2I(sidD, ctrD, dl);
            if checksign(sigf, pk(KM_VENDOR)) = ok() then
              let m = getmess(sigf) in
              if m = hash(image_to_bitstring(fw)) then
                if digest = hash(image_to_bitstring(fw)) then
                  event authenticated(digest, bs2str(uri_hint));
                  event DownloadDone(reqId, provId, uri_hint, fw);
                  event ReadyToApply(sidD);
                  (* ApplyUpdateRequest(UpdateToken, NewVersion) *)
                  let areq = M_APPLY_REQ(utok, nsv) in
                  new ctr_i2r2:bitstring;
                  let aadA = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2, nil, nil) in
                  let nA = nonce(SECFLAGS_UNICAST, ctr_i2r2, src_ctx) in
                  event SendI2R(sid, ctr_i2r2, areq);
                  event ApplyReqSent(sid, utok);
                  out(net, (aadA, aead_enc(k_i2r, areq, nA, aadA)));
                  in(net, (aadAR:bitstring, ctAR:bitstring));
                  let (mfAR:bitstring, sidAR:bitstring, sfAR:bitstring, ctrAR:bitstring, srcAR:bitstring, dstAR:bitstring) = aadAR in
                  let nAR = nonce(sfAR, ctrAR, src_ctx) in
                  if aead_dec_validate(k_r2i, ctAR, nAR, aadAR) = ok() then
                    let rAR = aead_dec(k_r2i, ctAR, nAR, aadAR) in
                    let M_APPLY_RESP(act:bitstring, dlyA:bitstring) = rAR in
                    event RecvR2I(sidAR, ctrAR, rAR);
                    event ApplyRespRcv(sidAR, act);
                    if act = ACT_PROCEED then
                      event OTAEnd(reqId, provId, nsv);
                      event endR(); 0
                    else 0
                  else 0
                else 0
              else 0
            else 0
          else 0
        else 0
      else 0
    (* === CASE 2: QI_BUSY → re-query stesso provider una volta === *)
    else if is_QI_BUSY(r) = ok() then
      let QI_BUSY(dly2:bitstring) = r in
      event RecvR2I(sidR, ctrR, r);
      event BusyRcv(provId);
      let q2 = M_QI(VID, PID, CUR()) in
      new ctr_i2r1b:bitstring;
      let aadQb = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1b, nil, nil) in
      let nQb = nonce(SECFLAGS_UNICAST, ctr_i2r1b, src_ctx) in
      event RequerySameProv(provId);
      event SendI2R(sid, ctr_i2r1b, q2);
      out(net, (aadQb, aead_enc(k_i2r, q2, nQb, aadQb)));
      in(net, (aadRb:bitstring, ctRb:bitstring));
      let (mfRb:bitstring, sidRb:bitstring, sfRb:bitstring, ctrRb:bitstring, srcRb:bitstring, dstRb:bitstring) = aadRb in
      let nRb = nonce(sfRb, ctrRb, src_ctx) in
      if aead_dec_validate(k_r2i, ctRb, nRb, aadRb) = ok() then
        let rb = aead_dec(k_r2i, ctRb, nRb, aadRb) in
        if is_QI_AVAIL(rb) = ok() then
          (* NSV, UpdateToken, Delay, ImageURI, VersionString *)
          let QI_AVAIL(nsvb:bitstring, utokb:bitstring, dlyb:bitstring, uri_hintb:bitstring, vstrb:string) = rb in
          event RecvR2I(sidRb, ctrRb, rb);
          if ver_gt(nsvb, CUR()) = ok() then
            event VersionAccepted(CUR(), nsvb);
            if uri_ok(uri_hintb) = ok() then
              in(net, (aadDb:bitstring, ctDb:bitstring));
              let (mfDb:bitstring, sidDb:bitstring, sfDb:bitstring, ctrDb:bitstring, srcDb:bitstring, dstDb:bitstring) = aadDb in
              let nDb = nonce(sfDb, ctrDb, src_ctx) in
              if aead_dec_validate(k_r2i, ctDb, nDb, aadDb) = ok() then
                let dlb = aead_dec(k_r2i, ctDb, nDb, aadDb) in
                let M_DL(fwb:image, digestb:bitstring, sigfb:bitstring) = dlb in
                event RecvR2I(sidDb, ctrDb, dlb);
                if checksign(sigfb, pk(KM_VENDOR)) = ok() then
                  let mb = getmess(sigfb) in
                  if mb = hash(image_to_bitstring(fwb)) then
                    if digestb = hash(image_to_bitstring(fwb)) then
                      event authenticated(digestb, bs2str(uri_hintb));
                      event DownloadDone(reqId, provId, uri_hintb, fwb);
                      (* === APPLY inline con utokb + nuova versione === *)
                      let areqb = M_APPLY_REQ(utokb, nsvb) in
                      new ctr_i2r2b:bitstring;
                      let aadAb = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2b, nil, nil) in
                      let nAb = nonce(SECFLAGS_UNICAST, ctr_i2r2b, src_ctx) in
                      event SendI2R(sid, ctr_i2r2b, areqb);
                      event ApplyReqSent(sid, utokb);
                      out(net, (aadAb, aead_enc(k_i2r, areqb, nAb, aadAb)));
                      in(net, (aadARb:bitstring, ctARb:bitstring));
                      let (mfARb:bitstring, sidARb:bitstring, sfARb:bitstring, ctrARb:bitstring, srcARb:bitstring, dstARb:bitstring) = aadARb in
                      let nARb = nonce(sfARb, ctrARb, src_ctx) in
                      if aead_dec_validate(k_r2i, ctARb, nARb, aadARb) = ok() then
                        let rARb = aead_dec(k_r2i, ctARb, nARb, aadARb) in
                        let M_APPLY_RESP(actb:bitstring, dlyAb:bitstring) = rARb in
                        event RecvR2I(sidARb, ctrARb, rARb);
                        event ApplyRespRcv(sidARb, actb);
                        if actb = ACT_PROCEED then
                          event OTAEnd(reqId, provId, nsvb);
                          event endR(); 0
                        else 0
                      else 0
                    else 0
                  else 0
                else 0
              else 0
            else 0
          else 0
        else 0
      else 0
    else 0
  else 0.

(* 2) Busy poi Available: prima QI_BUSY, poi attende una re-Query e prosegue *)
let ProviderBusyThenAvail(provId:bitstring, k_i2r:key, k_r2i:key, sid:bitstring, src_ctx:bitstring) =
  (* prima query *)
  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
    let msg1 = aead_dec(k_i2r, ctQ, nQ, aadQ) in
    let M_QI(vid1:bitstring, pid1:bitstring, csv1:bitstring) = msg1 in
    event RecvI2R(sidQ, ctrQ, msg1);
    (* rispondi Busy *)
    new dlyB:bitstring;
    let rb = QI_BUSY(dlyB) in
    new ctr_r2iB:bitstring;
    let aadB = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2iB, nil, nil) in
    let nB = nonce(SECFLAGS_UNICAST, ctr_r2iB, src_ctx) in
    event SendR2I(sid, ctr_r2iB, rb);
    out(net, (aadB, aead_enc(k_r2i, rb, nB, aadB)));
    (* seconda query (re-query) *)
    in(net, (aadQ2:bitstring, ctQ2:bitstring));
    let (mfQ2:bitstring, sidQ2:bitstring, sfQ2:bitstring, ctrQ2:bitstring, srcQ2:bitstring, dstQ2:bitstring) = aadQ2 in
    let nQ2 = nonce(sfQ2, ctrQ2, src_ctx) in
    if aead_dec_validate(k_i2r, ctQ2, nQ2, aadQ2) = ok() then
      let msg2 = aead_dec(k_i2r, ctQ2, nQ2, aadQ2) in
      let M_QI(vid2:bitstring, pid2:bitstring, csv2:bitstring) = msg2 in
      event RecvI2R(sidQ2, ctrQ2, msg2);
      (* prendi i dati reali dal Vendor *)
      in(cv, (u:bitstring, dig:bitstring, fw:image, sigf:bitstring, nsv:bitstring));
      new utok:bitstring;
      event TokenIssuedSID(sid, utok);
      new dlyR:bitstring;
      let vstr = bs2str(nsv) in
      (* Status = UpdateAvailable *)
      let resp = QI_AVAIL(nsv, utok, dlyR, u, vstr) in
      new ctr_r2i1:bitstring;
      let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
      let nR = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
      event SendR2I(sid, ctr_r2i1, resp);
      event QueryAnsweredP(provId, VID, PID, nsv);
      out(net, (aadR, aead_enc(k_r2i, resp, nR, aadR)));
      (* download con i valori del Vendor *)
      event DownloadStart(provId, u, image_to_bitstring(fw));
      let dl = M_DL(fw, dig, sigf) in
      new ctr_r2i2:bitstring;
      let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
      let nD = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
      event SendR2I(sid, ctr_r2i2, dl);
      out(net, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
      (* apply *)
      in(net, (aadA:bitstring, ctA:bitstring));
      let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
      let nA = nonce(sfA, ctrA, src_ctx) in
      if aead_dec_validate(k_i2r, ctA, nA, aadA) = ok() then
        let areq = aead_dec(k_i2r, ctA, nA, aadA) in
        (* ApplyUpdateRequest(UpdateToken, NewVersion) *)
        let M_APPLY_REQ(tk:bitstring, nv:bitstring) = areq in
        event RecvI2R(sidA, ctrA, areq);
        event ApplyReqRcv(sidA, tk);
        (* coerenza: NewVersion deve essere quella annunciata *)
        if nv = nsv then
          new delay:bitstring;
          let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
          new ctr_r2i3:bitstring;
          let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
          let nAR = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
          event SendR2I(sid, ctr_r2i3, aresp);
          event ApplyRespSent(sid, ACT_PROCEED);
          out(net, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
          event endP(); 0
        else 0
      else 0
    else 0
  else 0.

(* === Proprietà === *)
query attacker(sk(KM_VENDOR)).

(* Done ⇒ Start dallo stesso provider/oggetto *)
query r:bitstring, p:bitstring, u:bitstring, f:image;
  event(DownloadDone(r, p, u, f)) ==> event(DownloadStart(p, u, image_to_bitstring(f))).

(* Correttezza della firma: authenticated ⇒ issued *)
query sw:bitstring, swd:string;
  event(authenticated(sw, swd)) ==> event(issued(sw, swd)).

(* Prima rispondo a QI, poi inizio il download *)
query p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:image;
  event(DownloadStart(p, u, image_to_bitstring(f))) ==> event(QueryAnsweredP(p, vid, pid, nsv)).

(* Anti-replay “forte” *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* Anti-replay specifico per Apply *)
query sid:bitstring, act:bitstring;
  event(ApplyRespRcv(sid, act)) ==> inj-event(ApplyRespSent(sid, act)).
query sid:bitstring, tok:bitstring;
  event(ApplyReqRcv(sid, tok)) ==> inj-event(ApplyReqSent(sid, tok)).

(* Monotonicità versione accettata *)
query cur:bitstring, newv:bitstring;
  event(VersionAccepted(cur, newv)) ==> ver_gt(newv, cur) = ok().

(* Reachability *)
query event(endP()).
query event(endR()).

(* === Processo: più sessioni concorrenti === *)
process
  !(
    new k_i2r : key;
    new k_r2i : key;
    new ReqId : bitstring;
    new ProvId : bitstring;
    new SESSID : bitstring;
    new SRC_CTX : bitstring;
    (
      Vendor()
    | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
      (* | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) *)
    | ProviderBusyThenAvail(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
    )
  ).
