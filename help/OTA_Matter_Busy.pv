(* Canale pubblico *)
free net : channel.
const nil: bitstring.

(* === Tipi e primitive base === *)
type key.
type keymat.
type pkey.
type skey.
type result.
fun ok(): result.

(* Nuovo tipo per il firmware *)
type image.
fun image_to_bitstring(image): bitstring [data, typeConverter].

(* Supporto per descrizioni testuali negli eventi *)
type string.
fun bs2str(bitstring): string [data, typeConverter].

(* AEAD *)
fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.

reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = ok().

(* Hash *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* Firma VENDOR *)
fun pk(keymat): pkey.
fun sk(keymat): skey.
fun sign(bitstring, skey): bitstring.

reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Chiave vendor: segreta; la pubblica è pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Canale privato Vendor->Provider *)
free cv : channel [private].

(* Costanti Message Layer *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* Messaggi applicativi con tag “forte” *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].  (* (VID, PID, CUR()) *)

(* QueryImageResponse: Status = UpdateAvailable *)
(* campi: NSV (SoftwareVersion), utok (UpdateToken), dly, ImageURI, VersionString *)
fun QI_AVAIL(bitstring, bitstring, bitstring, bitstring, string): bitstring [data].

fun QI_BUSY(bitstring): bitstring [data].
fun QI_NOTAVAIL(): bitstring [data].

(* Predicati di forma per branch sicuri *)
reduc forall a:bitstring,b:bitstring,c:bitstring,u:bitstring,vs:string;
  is_QI_AVAIL(QI_AVAIL(a,b,c,u,vs)) = ok().
reduc forall d:bitstring; is_QI_BUSY(QI_BUSY(d)) = ok().
reduc is_QI_NOTAVAIL(QI_NOTAVAIL()) = ok().


(* Download: ora il 2° argomento è image *)
fun M_DL(image, bitstring, bitstring): bitstring [data].  (* (URI, FWIMG, digest, sig) *)

(* Apply step *)
(* ApplyUpdateRequest(UpdateToken, NewVersion) *)
fun M_APPLY_REQ(bitstring, bitstring): bitstring [data].
fun M_APPLY_RESP(bitstring, bitstring): bitstring [data].            (* (Action, Delay) *)
free ACT_PROCEED : bitstring.
free ACT_AWAIT   : bitstring.
free ACT_DISCONTINUE : bitstring.

(* --- Dati demo --- *)
free VID   : bitstring.
free PID   : bitstring.
fun CUR(): bitstring [data].
fun NEW(): bitstring [data].     (* lasciato per compatibilità, non usato per ver_gt *)
fun URI(): bitstring.            (* costruttore a 0 argomenti *)

(* === Versioni (monotonicità semplificata) === *)
fun ver_gt(bitstring, bitstring): result.
equation ver_gt(NEW(), CUR()) = ok().

(* URI utilizzabile *)
fun uri_ok(bitstring): result.
equation uri_ok(URI()) = ok().

(* Eventi *)
event OTABegin(bitstring, bitstring, bitstring).
event OTAEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, image).

event SendI2R(bitstring, bitstring, bitstring).
event SendR2I(bitstring, bitstring, bitstring).
event RecvI2R(bitstring, bitstring, bitstring).
event RecvR2I(bitstring, bitstring, bitstring).

(* Busy/re-query *)
event BusyRcv(bitstring).
event RequerySameProv(bitstring).

(* Verifica stile “issued/authenticated” sul contenuto firmato *)
event issued(bitstring, string).         (* sw = digest/firmware-id, swd = descrizione es. URI *)
event authenticated(bitstring, string).

(* Apply / token tracking *)
event TokenIssuedSID(bitstring, bitstring).
event ReadyToApply(bitstring).           (* sid *)
event ApplyReqSent(bitstring, bitstring, bitstring).(* sid, token *)
event ApplyReqRcv (bitstring, bitstring, bitstring).(* sid, token, new_version *)
event ApplyRespSent(bitstring, bitstring).
event ApplyRespRcv (bitstring, bitstring).
event VersionAccepted(bitstring, bitstring). (* CUR(), NSV *)

event endP().
event endR().

(* === VENDOR: invia tutto su cv come tupla; emette 'issued' sul pair (digest, URI) === *)
let Vendor() =
  new fwimg : image;
  let fwbs = image_to_bitstring(fwimg) in
  let dg   = hash(fwbs) in
  let sigf = sign(dg, sk(KM_VENDOR)) in
  let nsv  = NEW() in           (* il Vendor annuncia la versione successiva *)
  event issued(dg, bs2str(URI()));
  out(cv, (URI(), dg, fwimg, sigf, nsv)).

(* === Provider parametrico === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
    let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
    let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
    event RecvI2R(sidQ, ctrQ, msg);

    (* ricevi la tupla dal Vendor: include anche la nuova versione numerica nsv *)
    in(cv, (u:bitstring, dig:bitstring, fw:image, sigf:bitstring, nsv:bitstring));

    new utok: bitstring;
    event TokenIssuedSID(sid, utok);
    new dlyR: bitstring;

    (* VersionString: qui la otteniamo come conversione (modellata) del numero di versione *)
    let vstr = bs2str(nsv) in

    (* STATUS = UpdateAvailable: includiamo NSV, token, delay, ImageURI, VersionString *)
    let resp = QI_AVAIL(nsv, utok, dlyR, u, vstr) in

    new ctr_r2i1: bitstring;
    let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
    let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
    event SendR2I(sid, ctr_r2i1, resp);
    event QueryAnsweredP(provId, VID, PID, nsv);
    out(net, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

    (* download: usa i valori ricevuti *)
    event DownloadStart(provId, u, image_to_bitstring(fw));
    let dl = M_DL(fw, dig, sigf) in
    new ctr_r2i2: bitstring;
    let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
    let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
    event SendR2I(sid, ctr_r2i2, dl);
    out(net, (aadD, aead_enc(k_r2i, dl, nD, aadD)));

    in(net, (aadA:bitstring, ctA:bitstring));
    let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
    let nA = nonce(sfA, ctrA, src_ctx) in
    if aead_dec_validate(k_i2r, ctA, nA, aadA) = ok() then
      let areq = aead_dec(k_i2r, ctA, nA, aadA) in
      (* ApplyUpdateRequest(UpdateToken, NewVersion) *)
      let M_APPLY_REQ(tk:bitstring, nv:bitstring) = areq in
      event RecvI2R(sidA, ctrA, areq);
      event ApplyReqRcv(sidA, tk, nv);

      (* Coerenza: NewVersion deve essere la NSV annunciata *)
      if nv = nsv then
        new delay: bitstring;
        let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
        new ctr_r2i3: bitstring;
        let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
        let nAR   = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
        event SendR2I(sid, ctr_r2i3, aresp);
        event ApplyRespSent(sid, ACT_PROCEED);
        out(net, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
        event endP(); 0
      else 0
    else 0.

(* === Requestor con gestione stati QI + “loop” === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  event OTABegin(reqId, provId, CUR());

  let q = M_QI(VID, PID, CUR()) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, CUR());
  out(net, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  in(net, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  if aead_dec_validate(k_r2i, ctR, nR, aadR) = ok() then
  let r = aead_dec(k_r2i, ctR, nR, aadR) in

  

  (* === CASE 2: QI_BUSY === *)
  if is_QI_BUSY(r) = ok() then
    let QI_BUSY(dly2:bitstring) = r in
    event RecvR2I(sidR, ctrR, r);
    event BusyRcv(provId);
    event endR(); 0

  (* === ALTRO === *)
  else 0

else 0.




(* 2) Busy poi Available: prima QI_BUSY, poi attende una re-Query e prosegue *)
let ProviderBusyThenAvail(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* prima query *)
  in(net, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  if aead_dec_validate(k_i2r, ctQ, nQ, aadQ) = ok() then
    let msg1 = aead_dec(k_i2r, ctQ, nQ, aadQ) in
    let M_QI(vid1:bitstring, pid1:bitstring, csv1:bitstring) = msg1 in
    event RecvI2R(sidQ, ctrQ, msg1);

    (* rispondi Busy *)
    new dlyB: bitstring;
    let rb = QI_BUSY(dlyB) in
    new ctr_r2iB: bitstring;
    let aadB = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2iB, nil, nil) in
    let nB   = nonce(SECFLAGS_UNICAST, ctr_r2iB, src_ctx) in
    event SendR2I(sid, ctr_r2iB, rb);
    out(net, (aadB, aead_enc(k_r2i, rb, nB, aadB)));
    event endP(); 0 (* termina la sessione corrente *)

  else 0.



(* === Proprietà === *)

query attacker(sk(KM_VENDOR)).


(* Anti-replay “forte” *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* Reachability *)
query event(endP()).
query event(endR()).

(* === Processo: più sessioni concorrenti === *)
process
  !(
     new k_i2r : key; 
     new k_r2i : key; 
     new ReqId : bitstring;
     new ProvId: bitstring;
     new SESSID: bitstring;
     new SRC_CTX: bitstring;
     ( Vendor()
     | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     (* | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) *)
     | ProviderBusyThenAvail(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
    )
  )