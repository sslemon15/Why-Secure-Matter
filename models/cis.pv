(* Canale pubblico *)
free c : channel.
const nil: bitstring.

(* === Tipi e primitive base === *)
type key.
type keymat.
type pkey.
type skey.
type result.

(* AEAD con AAD e Nonce espliciti *)
fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = true.

(* Hash astratto *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* Firma del VENDOR *)
fun ok(): result.
fun pk(keymat): pkey.
fun sk(keymat): skey.
fun sign(bitstring, skey): bitstring.


(* Regole firma *)
reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Chiave vendor: segreta; la pubblica è il termine pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Canale privato Vendor->Provider *)
free cv : channel [private].

(* Costanti del Message Layer (astratte) *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* Messaggi applicativi con tag “forte” *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].            (* (VID, PID, CUR()) *)
fun M_QIR(bitstring, bitstring): bitstring [data].                      (* (NEW(), UpdateToken) *)
fun M_DL(bitstring, bitstring, bitstring, bitstring): bitstring [data]. (* (URI, FWIMG, digest, sig) *)

(* Apply step *)
fun M_APPLY_REQ(bitstring): bitstring [data].                           (* UpdateToken *)
fun M_APPLY_RESP(bitstring, bitstring): bitstring [data].               (* (Action, Delay) *)
free ACT_PROCEED : bitstring.
free ACT_AWAIT   : bitstring.

(* --- Dati demo --- *)
free VID   : bitstring.
free PID   : bitstring.
fun CUR(): bitstring [data].
fun NEW(): bitstring [data].
free URI   : bitstring.
free FWIMG : bitstring [private].

(* Predicato astratto “nuova versione strettamente maggiore” *)
fun ver_gt(bitstring, bitstring): result.
equation ver_gt(NEW(), CUR()) = ok().

(* Eventi *)
event CaseBegin(bitstring, bitstring, bitstring).
event CaseEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring).       (* provId, VID, PID, NEW() *)
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, bitstring).

event SendI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event SendR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)

(* Apply / token tracking *)
event TokenIssuedSID(bitstring, bitstring).                 (* sid, token *)
event ApplyReqSent(bitstring, bitstring).                   (* sid, token *)
event ApplyReqRcv (bitstring, bitstring).                   (* sid, token *)
event ApplyRespSent(bitstring, bitstring, bitstring).       (* sid, token, action *)
event ApplyRespRcv (bitstring, bitstring, bitstring).       (* sid, token, action *)
event FallbackTokenUsedSID(bitstring, bitstring).           (* sid, token (= src_ctx) *)
event VersionAccepted(bitstring, bitstring).                (* CUR(), NEW() *)

event endP().
event endR().

(* === VENDOR: firma l’immagine e consegna la firma al Provider su canale privato === *)
let Vendor() =
  let sigf = sign(hash(FWIMG), sk(KM_VENDOR)) in
  out(cv, sigf).

(* === Provider parametrico su SessionID e Source-Node-ID di sessione === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* ricevo QueryImage *)
  in(c, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
  let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
  event RecvI2R(sidQ, ctrQ, msg);

  (* firma dal VENDOR su canale privato *)
  in(cv, sigf:bitstring);

  (* genera UpdateToken e manda QIR *)
  new utok: bitstring;                 (* UpdateToken fresco *)
  event TokenIssuedSID(sid, utok);
  let resp = M_QIR(NEW(), utok) in
  new ctr_r2i1: bitstring;
  let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
  let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
  event SendR2I(sid, ctr_r2i1, resp);
  event QueryAnsweredP(provId, VID, PID, NEW());
  out(c, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

  (* invio download: digest + firma del VENDOR *)
  event DownloadStart(provId, URI, FWIMG);
  let digest = hash(FWIMG) in
  let dl     = M_DL(URI, FWIMG, digest, sigf) in
  new ctr_r2i2: bitstring;
  let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
  let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
  event SendR2I(sid, ctr_r2i2, dl);
  out(c, (aadD, aead_enc(k_r2i, dl, nD, aadD)));

  (* ricevo ApplyUpdateRequest *)
  in(c, (aadA:bitstring, ctA:bitstring));
  let (mfA:bitstring, sidA:bitstring, sfA:bitstring, ctrA:bitstring, srcA:bitstring, dstA:bitstring) = aadA in
  let nA = nonce(sfA, ctrA, src_ctx) in
  let areq = aead_dec(k_i2r, ctA, nA, aadA) in
  let M_APPLY_REQ(tk:bitstring) = areq in
  event RecvI2R(sidA, ctrA, areq);
  event ApplyReqRcv(sidA, tk);

  (* policy semplice: sempre PROCEED *)
  new delay: bitstring;
  let aresp = M_APPLY_RESP(ACT_PROCEED, delay) in
  new ctr_r2i3: bitstring;
  let aadAR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
  let nAR   = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
  event SendR2I(sid, ctr_r2i3, aresp);
  event ApplyRespSent(sid, tk, ACT_PROCEED);
  out(c, (aadAR, aead_enc(k_r2i, aresp, nAR, aadAR)));
  event endP();
  0.

(* === Requestor parametrico su SessionID e Source-Node-ID di sessione === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  event CaseBegin(reqId, provId, NEW());

  (* invio QueryImage *)
  let q = M_QI(VID, PID, CUR()) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, CUR());
  out(c, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* ricezione risposta: (NEW(), UpdateToken) *)
  in(c, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  let r = aead_dec(k_r2i, ctR, nR, aadR) in
  let M_QIR(nsv:bitstring, utok:bitstring) = r in
  event RecvR2I(sidR, ctrR, r);

  (* aggiorna solo se nsv > CUR() *)
  if ver_gt(nsv, CUR()) = ok() then
    event VersionAccepted(CUR(), nsv);

    (* ricezione download + verifiche digest+firma *)
    in(c, (aadD:bitstring, ctD:bitstring));
    let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
    let nD = nonce(sfD, ctrD, src_ctx) in
    let dl = aead_dec(k_r2i, ctD, nD, aadD) in
    let M_DL(uri2:bitstring, fw:bitstring, digest:bitstring, sigf:bitstring) = dl in
    event RecvR2I(sidD, ctrD, dl);

    if hash(fw) = digest then
      let m = getmess(sigf) in
      if m = hash(fw) then
        if checksign(sigf, pk(KM_VENDOR)) = ok() then
          event DownloadDone(reqId, provId, uri2, fw);

          (* APPLY: invio ApplyUpdateRequest con l’UpdateToken registrato *)
          let areq = M_APPLY_REQ(utok) in
          new ctr_i2r2: bitstring;
          let aadA = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2, nil, nil) in
          let nA   = nonce(SECFLAGS_UNICAST, ctr_i2r2, src_ctx) in
          event SendI2R(sid, ctr_i2r2, areq);
          event ApplyReqSent(sid, utok);
          out(c, (aadA, aead_enc(k_i2r, areq, nA, aadA)));

          (* risposta ApplyUpdateResponse *)
          in(c, (aadAR:bitstring, ctAR:bitstring));
          let (mfAR:bitstring, sidAR:bitstring, sfAR:bitstring, ctrAR:bitstring, srcAR:bitstring, dstAR:bitstring) = aadAR in
          let nAR = nonce(sfAR, ctrAR, src_ctx) in
          let rAR = aead_dec(k_r2i, ctAR, nAR, aadAR) in
          let M_APPLY_RESP(act:bitstring, dly:bitstring) = rAR in
          event RecvR2I(sidAR, ctrAR, rAR);
          event ApplyRespRcv(sidAR, utok, act);

          if act = ACT_PROCEED then
            event CaseEnd(reqId, provId, nsv);
            event endR(); 0
          else 0
        else 0
      else 0
    else 0
  else 0.

(* === Proprietà === *)

(* Confidenzialità del firmware nella sessione sicura *)
query attacker(FWIMG).

(* Done ⇒ Start dallo stesso provider/oggetto *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring;
  event(DownloadDone(r, p, u, f)) ==> event(DownloadStart(p, u, f)).

(* Done legato all’esatto plaintext inviato (digest+firma del Vendor) *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring, sid:bitstring, ctr:bitstring;
  event(DownloadDone(r, p, u, f))
  ==> inj-event(SendR2I(sid, ctr, M_DL(u, f, hash(f), sign(hash(f), sk(KM_VENDOR))))).

(* Prima rispondo a QI, poi inizio il download *)
query p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:bitstring;
  event(DownloadStart(p, u, f)) ==> event(QueryAnsweredP(p, vid, pid, nsv)).

(* Anti-replay “locale”: stesso (sid,ctr) ⇒ stesso plaintext *)
query sid0:bitstring, ctr0:bitstring, m1:bitstring, m2:bitstring;
  event(RecvI2R(sid0, ctr0, m1)) && event(RecvI2R(sid0, ctr0, m2)) ==> m1 = m2.
query sid1:bitstring, ctr1:bitstring, n1:bitstring, n2:bitstring;
  event(RecvR2I(sid1, ctr1, n1)) && event(RecvR2I(sid1, ctr1, n2)) ==> n1 = n2.

(* Anti-replay “forte”: ogni ricezione proviene da un invio distinto *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* === Nuove proprietà Apply/Token === *)
query sid:bitstring, tok:bitstring, act:bitstring;
  event(ApplyRespRcv(sid, tok, act)) ==> inj-event(ApplyReqSent(sid, tok)).

query sid:bitstring, tok:bitstring;
  event(ApplyReqSent(sid, tok)) ==> event(TokenIssuedSID(sid, tok)).

(* (opzionale) Unicità del token tra sessioni *)
query s1:bitstring, s2:bitstring, tok:bitstring;
  event(TokenIssuedSID(s1, tok)) && event(TokenIssuedSID(s2, tok)) ==> s1 = s2.

(* Reachability (sanity) *)
query event(endP()).
query event(endR()).

(* === Processo: più sessioni concorrenti === *)
process
  !(
     new k_i2r : key;
     new k_r2i : key;
     new ReqId : bitstring;
     new ProvId: bitstring;
     new SESSID: bitstring;
     new SRC_CTX: bitstring;
     ( Vendor()
     | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) )
   )
