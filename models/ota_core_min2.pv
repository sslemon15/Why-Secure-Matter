(* Canale pubblico *)
free c : channel.
const nil: bitstring.

(* === Tipi e primitive base === *)
type key.
type keymat.
type pkey.
type skey.
type result.

(* AEAD con AAD e Nonce espliciti *)
fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = true.

(* Hash astratto *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* Firma del VENDOR *)
fun ok(): result.
fun pk(keymat): pkey.
fun sk(keymat): skey.
fun sign(bitstring, skey): bitstring.
(* Regole firma *)
reduc forall m:bitstring, y:keymat; getmess(sign(m, sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m, sk(y)), pk(y)) = ok().

(* Chiave vendor: segreta; la pubblica è il termine pk(KM_VENDOR) *)
const KM_VENDOR : keymat [private].

(* Canale privato Vendor->Provider *)
free cv : channel [private].

(* Costanti del Message Layer (astratte) *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* Messaggi applicativi con tag “forte” *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].            (* (VID, PID, curSV) *)
fun M_QIR(bitstring): bitstring [data].                                 (* newSV *)
fun M_DL(bitstring, bitstring, bitstring, bitstring): bitstring [data]. (* (URI, FWIMG, digest, sig) *)

(* Eventi *)
event CaseBegin(bitstring, bitstring, bitstring).
event CaseEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, bitstring).

event SendI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event SendR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)

event endP().
event endR().

(* Dati demo *)
free VID   : bitstring.
free PID   : bitstring.
free curSV : bitstring.
free newSV : bitstring.
free URI   : bitstring.
free FWIMG : bitstring [private].

(* === VENDOR: firma l’immagine e consegna la firma al Provider su canale privato === *)
let Vendor() =
  let sigf = sign(hash(FWIMG), sk(KM_VENDOR)) in
  out(cv, sigf).

(* === Provider parametrico su SessionID e Source-Node-ID di sessione === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* ricevo QueryImage *)
  in(c, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
  let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
  event RecvI2R(sidQ, ctrQ, msg);

  (* ricevo la firma dal VENDOR su canale privato *)
  in(cv, sigf:bitstring);

  (* invio risposta *)
  let resp = M_QIR(newSV) in
  new ctr_r2i1: bitstring;
  let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
  let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
  event SendR2I(sid, ctr_r2i1, resp);
  event QueryAnsweredP(provId, VID, PID, newSV);
  out(c, (aadR, aead_enc(k_r2i, resp, nR, aadR)));



  (* invio download: digest + firma del VENDOR *)
  event DownloadStart(provId, URI, FWIMG);
  let digest = hash(FWIMG) in
  let dl     = M_DL(URI, FWIMG, digest, sigf) in
  new ctr_r2i2: bitstring;
  let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
  let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
  event SendR2I(sid, ctr_r2i2, dl);
  out(c, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
  event endP();
  0.

(* === Requestor parametrico su SessionID e Source-Node-ID di sessione === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  event CaseBegin(reqId, provId, newSV);

  (* invio QueryImage *)
  let q = M_QI(VID, PID, curSV) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, curSV);
  out(c, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* ricezione risposta *)
  in(c, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  let r = aead_dec(k_r2i, ctR, nR, aadR) in
  let M_QIR(nsv:bitstring) = r in
  event RecvR2I(sidR, ctrR, r);

  (* ricezione download + verifiche digest+firma *)
  in(c, (aadD:bitstring, ctD:bitstring));
  let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
  let nD = nonce(sfD, ctrD, src_ctx) in
  let dl = aead_dec(k_r2i, ctD, nD, aadD) in
  let M_DL(uri2:bitstring, fw:bitstring, digest:bitstring, sigf:bitstring) = dl in
  event RecvR2I(sidD, ctrD, dl);

  if hash(fw) = digest then
    let m = getmess(sigf) in
    if m = hash(fw) then
      if checksign(sigf, pk(KM_VENDOR)) = ok() then
        event DownloadDone(reqId, provId, uri2, fw);
        event CaseEnd(reqId, provId, nsv);
        event endR();
        0
      else 0
    else 0
  else 0.

(* === Proprietà === *)

(* Confidenzialità del firmware nella sessione sicura *)
query attacker(FWIMG).

(* Done ⇒ Start dallo stesso provider/oggetto *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring;
  event(DownloadDone(r, p, u, f)) ==> event(DownloadStart(p, u, f)).

(* Done legato all’esatto plaintext inviato (inclusa la firma del Vendor) *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring, sid:bitstring, ctr:bitstring;
  event(DownloadDone(r, p, u, f))
  ==> inj-event(SendR2I(sid, ctr, M_DL(u, f, hash(f), sign(hash(f), sk(KM_VENDOR))))).

(* Prima rispondo a QI, poi inizio il download *)
query p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:bitstring;
  event(DownloadStart(p, u, f)) ==> event(QueryAnsweredP(p, vid, pid, nsv)).

(* Anti-replay “locale”: stesso (sid,ctr) ⇒ stesso plaintext *)
query sid0:bitstring, ctr0:bitstring, m1:bitstring, m2:bitstring;
  event(RecvI2R(sid0, ctr0, m1)) && event(RecvI2R(sid0, ctr0, m2)) ==> m1 = m2.
query sid1:bitstring, ctr1:bitstring, n1:bitstring, n2:bitstring;
  event(RecvR2I(sid1, ctr1, n1)) && event(RecvR2I(sid1, ctr1, n2)) ==> n1 = n2.

(* Anti-replay “forte”: ogni ricezione proviene da un invio distinto *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).


query event(endP()).
query event(endR()).

(* === Processo: più sessioni concorrenti, ciascuna con SESSID & SRC_CTX fresh === *)
process
  !(
     new k_i2r : key;
     new k_r2i : key;
     new ReqId : bitstring;
     new ProvId: bitstring;
     new SESSID: bitstring;
     new SRC_CTX: bitstring;
     ( Vendor()
     | Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) )
   )
