(* --- Settings per performance/terminazione --- *)
set movelet = true.
set movenew = true.
(* set maxDepth = 6. *)
(* set verboseTerm = true. *)
(* set verboseStatistics = true. *)

(* Canale pubblico *)
free c : channel.
const nil: bitstring.

(* Tipi e primitive *)
type key.

(* AEAD con AAD e Nonce espliciti (come nel Message Layer) *)
fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
(* Evita clausole superflue *)
(* reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = true. *)

(* Hash astratto *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

(* Costanti del Message Layer (astratte) *)
free MSGFLAGS          : bitstring.
free SECFLAGS_UNICAST  : bitstring.

(* *** Messaggi applicativi con tag “forte” *** *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].        (* (VID, PID, curSV) *)
fun M_QIR(bitstring): bitstring [data].                             (* newSV *)
fun M_DL(bitstring, bitstring, bitstring): bitstring [data].        (* (URI, FWIMG, digest) *)

(* Eventi *)
event CaseBegin(bitstring, bitstring, bitstring).
event CaseEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring).
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, bitstring).
event FirmwareReceived(bitstring, bitstring, bitstring).

event SendI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event SendR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)

(* Sentinelle *)
event ReachedPhase5.
event FirmwareReceivedP(bitstring).  (* versione “leggera” per autenticità *)

(* Dati demo *)
free VID   : bitstring.
free PID   : bitstring.
free curSV : bitstring.
free newSV : bitstring.
free URI   : bitstring.
free FWIMG : bitstring [private].

(* === Provider parametrico su SessionID e Source-Node-ID di sessione === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* --- Round 1: ricevo QueryImage #1 --- *)
  phase 1;
  in(c, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
  let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
  event RecvI2R(sidQ, ctrQ, msg);
  event QueryAnsweredP(provId);

  (* Risposta #1 *)
  phase 2;
  let resp = M_QIR(newSV) in
  new ctr_r2i1: bitstring;
  let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
  let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
  event SendR2I(sid, ctr_r2i1, resp);
  out(c, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

  (* --- Round 2: ricevo QueryImage #2 --- *)
  phase 3;
  in(c, (aadQ2:bitstring, ctQ2:bitstring));
  let (mfQ2:bitstring, sidQ2:bitstring, sfQ2:bitstring, ctrQ2:bitstring, srcQ2:bitstring, dstQ2:bitstring) = aadQ2 in
  let nQ2 = nonce(sfQ2, ctrQ2, src_ctx) in
  let msg2 = aead_dec(k_i2r, ctQ2, nQ2, aadQ2) in
  let M_QI(vid2:bitstring, pid2:bitstring, csv2:bitstring) = msg2 in
  event RecvI2R(sidQ2, ctrQ2, msg2);
  event QueryAnsweredP(provId);

  (* Risposta #2 *)
  phase 4;
  let resp2 = M_QIR(newSV) in
  new ctr_r2i3: bitstring;
  let aadR2 = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i3, nil, nil) in
  let nR2   = nonce(SECFLAGS_UNICAST, ctr_r2i3, src_ctx) in
  event SendR2I(sid, ctr_r2i3, resp2);
  out(c, (aadR2, aead_enc(k_r2i, resp2, nR2, aadR2)));

  (* Download dopo i due round *)
  phase 5;
  event DownloadStart(provId, provId, URI);
  let digest = hash(FWIMG) in
  let dl = M_DL(URI, FWIMG, digest) in
  new ctr_r2i2: bitstring;
  let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
  let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
  event SendR2I(sid, ctr_r2i2, dl);
  out(c, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
  event ReachedPhase5;
  0.

(* === Requestor parametrico su SessionID e Source-Node-ID di sessione === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  event CaseBegin(reqId, provId, newSV);
  event QuerySent(reqId, provId, VID, PID, curSV);

  (* --- Round 1: invio QueryImage #1 --- *)
  phase 1;
  let q = M_QI(VID, PID, curSV) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  out(c, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* Ricezione risposta #1 *)
  phase 2;
  in(c, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  let r = aead_dec(k_r2i, ctR, nR, aadR) in
  let M_QIR(nsv:bitstring) = r in
  event RecvR2I(sidR, ctrR, r);

  (* --- Round 2: invio QueryImage #2 --- *)
  phase 3;
  let q2 = M_QI(VID, PID, curSV) in
  new ctr_i2r2: bitstring;
  let aadQ2 = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r2, nil, nil) in
  let nQ2   = nonce(SECFLAGS_UNICAST, ctr_i2r2, src_ctx) in
  event SendI2R(sid, ctr_i2r2, q2);
  out(c, (aadQ2, aead_enc(k_i2r, q2, nQ2, aadQ2)));

  (* Ricezione risposta #2 *)
  phase 4;
  in(c, (aadR2:bitstring, ctR2:bitstring));
  let (mfR2:bitstring, sidR2:bitstring, sfR2:bitstring, ctrR2:bitstring, srcR2:bitstring, dstR2:bitstring) = aadR2 in
  let nR2 = nonce(sfR2, ctrR2, src_ctx) in
  let r2 = aead_dec(k_r2i, ctR2, nR2, aadR2) in
  let M_QIR(nsv2:bitstring) = r2 in
  event RecvR2I(sidR2, ctrR2, r2);

  (* Download finale *)
  phase 5;
  in(c, (aadD:bitstring, ctD:bitstring));
  let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
  let nD = nonce(sfD, ctrD, src_ctx) in
  let dl = aead_dec(k_r2i, ctD, nD, aadD) in
  let M_DL(uri2:bitstring, fw:bitstring, digest:bitstring) = dl in
  event RecvR2I(sidD, ctrD, dl);
  event ReachedPhase5;
  if hash(fw) = digest then
    event DownloadDone(reqId, provId, uri2, fw);
    event FirmwareReceived(reqId, provId, fw);
    event FirmwareReceivedP(provId);     (* evento leggero per autenticità *)
    event CaseEnd(reqId, provId, nsv2);
    0
  else 0.

(* === Proprietà === *)

(* Confidenzialità del firmware nella sessione sicura *)
(* query attacker(FWIMG). *)
query attacker(FWIMG) ==> event(ReachedPhase5).

(* Autenticità di alto livello - versione leggera (veloce) *)
query p:bitstring; event(FirmwareReceivedP(p)) ==> event(QueryAnsweredP(p)).

(* [Opzionale] versione “pesante”: lancia questa da sola, in un run separato *)
(* query r:bitstring, p:bitstring, f:bitstring;
   event(FirmwareReceived(r, p, f)) ==> event(QueryAnsweredP(p)). *)

(* Anti-replay “locale”: stesso (sid,ctr) ⇒ stesso plaintext *)
query sid0:bitstring, ctr0:bitstring, m1:bitstring, m2:bitstring;
  event(RecvI2R(sid0, ctr0, m1)) && event(RecvI2R(sid0, ctr0, m2)) ==> m1 = m2.
query sid1:bitstring, ctr1:bitstring, n1:bitstring, n2:bitstring;
  event(RecvR2I(sid1, ctr1, n1)) && event(RecvR2I(sid1, ctr1, n2)) ==> n1 = n2.

(* Anti-replay “forte”: ogni ricezione proviene da un invio distinto *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).

(* === Un’unica sessione (senza !) per velocità; aggiungi “!” se vuoi concorrenza === *)
process
  (
     new k_i2r : key;           (* chiave I→R per sessione *)
     new k_r2i : key;           (* chiave R→I per sessione *)
     new ReqId : bitstring;
     new ProvId: bitstring;
     new SESSID: bitstring;     (* Session ID per sessione *)
     new SRC_CTX: bitstring;    (* NodeID per il Nonce, per sessione *)
     ( Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) )
  )
