(* Canale pubblico *)
free c : channel.
const nil: bitstring.

(* Tipi e primitive *)
type key.
type keymat.	(* key material *)
type pkey.	(* public key *)
type skey.	(* private key *)
type result.	(* result of check signature *)
type string.
(* AEAD con AAD e Nonce espliciti *)
fun aead_enc(key, bitstring, bitstring, bitstring): bitstring.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec(k, aead_enc(k, m, n, ad), n, ad) = m.
reduc forall k: key, m: bitstring, n: bitstring, ad: bitstring;
  aead_dec_validate(k, aead_enc(k, m, n, ad), n, ad) = true.

(* Hash astratto *)
fun hash(bitstring) : bitstring.

(* Nonce = SecurityFlags || MessageCounter || NonceSourceNodeID *)
fun nonce(bitstring, bitstring, bitstring): bitstring.

fun ok(): result.
fun pk(keymat): pkey.
fun sk(keymat): skey.

fun sign(bitstring, skey): bitstring.
reduc forall m:bitstring, y:keymat; getmess(sign(m,sk(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m,sk(y)), pk(y)) = ok().

event issued(bitstring,string).
event authenticated(bitstring,string).

query sw: bitstring, swd: string;
	event(authenticated(sw,swd)) ==> event(issued(sw,swd)).

(* Test reachability *)
event endR().
event endP().

query event(endP()).
query event(endR()).

(* Costanti del Message Layer (astratte) *)
free MSGFLAGS         : bitstring.
free SECFLAGS_UNICAST : bitstring.

(* Messaggi applicativi con tag “forte” *)
fun M_QI(bitstring, bitstring, bitstring): bitstring [data].        (* (VID, PID, curSV) *)
fun M_QIR(bitstring): bitstring [data].                             (* newSV *)
fun M_DL(bitstring, bitstring, bitstring): bitstring [data].        (* (URI, FWIMG, digest) *)

(* Eventi *)
event CaseBegin(bitstring, bitstring, bitstring).
event CaseEnd(bitstring, bitstring, bitstring).
event QuerySent(bitstring, bitstring, bitstring, bitstring, bitstring).
event QueryAnsweredP(bitstring, bitstring, bitstring, bitstring).
event DownloadStart(bitstring, bitstring, bitstring).
event DownloadDone(bitstring, bitstring, bitstring, bitstring).

event SendI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event SendR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvI2R(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)
event RecvR2I(bitstring, bitstring, bitstring).  (* sessid, ctr, plaintext *)

(* Dati demo *)
free VID   : bitstring.
free PID   : bitstring.
free curSV : bitstring.
free newSV : bitstring.
free URI   : bitstring.
free FWIMG : bitstring [private].

(* === Provider parametrico su SessionID e Source-Node-ID di sessione === *)
let Provider(provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  (* ricevo QueryImage *)
  in(c, (aadQ:bitstring, ctQ:bitstring));
  let (mfQ:bitstring, sidQ:bitstring, sfQ:bitstring, ctrQ:bitstring, srcQ:bitstring, dstQ:bitstring) = aadQ in
  let nQ = nonce(sfQ, ctrQ, src_ctx) in
  let msg = aead_dec(k_i2r, ctQ, nQ, aadQ) in
  let M_QI(vid:bitstring, pid:bitstring, csv:bitstring) = msg in
  event RecvI2R(sidQ, ctrQ, msg);

  (* invio risposta *)
  let resp = M_QIR(newSV) in
  new ctr_r2i1: bitstring;
  let aadR = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i1, nil, nil) in
  let nR   = nonce(SECFLAGS_UNICAST, ctr_r2i1, src_ctx) in
  event SendR2I(sid, ctr_r2i1, resp);
  event QueryAnsweredP(provId, VID, PID, newSV);
  out(c, (aadR, aead_enc(k_r2i, resp, nR, aadR)));

  (* invio download *)
  event DownloadStart(provId, URI, FWIMG);
  let digest = hash(FWIMG) in
  let dl = M_DL(URI, FWIMG, digest) in
  new ctr_r2i2: bitstring;
  let aadD = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_r2i2, nil, nil) in
  let nD   = nonce(SECFLAGS_UNICAST, ctr_r2i2, src_ctx) in
  event SendR2I(sid, ctr_r2i2, dl);
  out(c, (aadD, aead_enc(k_r2i, dl, nD, aadD)));
  event endP(); 0.

(* === Requestor parametrico su SessionID e Source-Node-ID di sessione === *)
let Requestor(reqId: bitstring, provId: bitstring, k_i2r: key, k_r2i: key, sid: bitstring, src_ctx: bitstring) =
  event CaseBegin(reqId, provId, newSV);

  (* invio QueryImage *)
  let q = M_QI(VID, PID, curSV) in
  new ctr_i2r1: bitstring;
  let aadQ = (MSGFLAGS, sid, SECFLAGS_UNICAST, ctr_i2r1, nil, nil) in
  let nQ   = nonce(SECFLAGS_UNICAST, ctr_i2r1, src_ctx) in
  event SendI2R(sid, ctr_i2r1, q);
  event QuerySent(reqId, provId, VID, PID, curSV);
  out(c, (aadQ, aead_enc(k_i2r, q, nQ, aadQ)));

  (* ricezione risposta *)
  in(c, (aadR:bitstring, ctR:bitstring));
  let (mfR:bitstring, sidR:bitstring, sfR:bitstring, ctrR:bitstring, srcR:bitstring, dstR:bitstring) = aadR in
  let nR = nonce(sfR, ctrR, src_ctx) in
  let r = aead_dec(k_r2i, ctR, nR, aadR) in
  let M_QIR(nsv:bitstring) = r in
  event RecvR2I(sidR, ctrR, r);

  (* ricezione download *)
  in(c, (aadD:bitstring, ctD:bitstring));
  let (mfD:bitstring, sidD:bitstring, sfD:bitstring, ctrD:bitstring, srcD:bitstring, dstD:bitstring) = aadD in
  let nD = nonce(sfD, ctrD, src_ctx) in
  let dl = aead_dec(k_r2i, ctD, nD, aadD) in
  let M_DL(uri2:bitstring, fw:bitstring, digest:bitstring) = dl in
  event RecvR2I(sidD, ctrD, dl);
  if hash(fw) = digest then
    event DownloadDone(reqId, provId, uri2, fw);
    event CaseEnd(reqId, provId, nsv);
    event endP(); 0
  else 0.

(* === Proprietà === *)

(* Confidenzialità del firmware nella sessione sicura *)
query attacker(FWIMG).

(* Done ⇒ Start dallo stesso provider/oggetto *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring;
  event(DownloadDone(r, p, u, f)) ==> event(DownloadStart(p, u, f)).

(* [NUOVA 1] Leghiamo il Done all’esatto plaintext inviato *)
query r:bitstring, p:bitstring, u:bitstring, f:bitstring, sid:bitstring, ctr:bitstring;
  event(DownloadDone(r, p, u, f))
  ==> inj-event(SendR2I(sid, ctr, M_DL(u, f, hash(f)))).

(* [NUOVA 2] “Prima rispondo al QI, poi inizio il download” *)
query p:bitstring, vid:bitstring, pid:bitstring, nsv:bitstring, u:bitstring, f:bitstring;
  event(DownloadStart(p, u, f))
  ==> event(QueryAnsweredP(p, vid, pid, nsv)).

(* Anti-replay “locale”: stesso (SessionID, direzione, counter) ⇒ stesso plaintext *)
query sid0:bitstring, ctr0:bitstring, m1:bitstring, m2:bitstring;
  event(RecvI2R(sid0, ctr0, m1)) && event(RecvI2R(sid0, ctr0, m2)) ==> m1 = m2.
query sid1:bitstring, ctr1:bitstring, n1:bitstring, n2:bitstring;
  event(RecvR2I(sid1, ctr1, n1)) && event(RecvR2I(sid1, ctr1, n2)) ==> n1 = n2.

(* Anti-replay “forte”: ogni ricezione proviene da un invio distinto *)
query sid2:bitstring, ctr2:bitstring, m:bitstring;
  event(RecvI2R(sid2, ctr2, m)) ==> inj-event(SendI2R(sid2, ctr2, m)).
query sid3:bitstring, ctr3:bitstring, n:bitstring;
  event(RecvR2I(sid3, ctr3, n)) ==> inj-event(SendR2I(sid3, ctr3, n)).


(* === Processo: più sessioni concorrenti, ciascuna con SESSID & SRC_CTX fresh === *)
process
  !(
     new k_i2r : key;           (* chiave direzionale Initiator->Responder, per sessione *)
     new k_r2i : key;           (* chiave direzionale Responder->Initiator, per sessione *)
     new ReqId : bitstring;
     new ProvId: bitstring;
     new SESSID: bitstring;     (* Session ID fresh per sessione *)
     new SRC_CTX: bitstring;    (* Nonce Source Node ID dal Secure Session Context, per sessione *)
     ( Requestor(ReqId, ProvId, k_i2r, k_r2i, SESSID, SRC_CTX)
     | Provider(ProvId, k_i2r, k_r2i, SESSID, SRC_CTX) )
   )
